{"posts":[{"title":"A multi-thread media stream in C++ based on OpenCV and OpenGL","text":"Video DisplayWe did the video capture using OpenCV, and the video display . FPS Modification Built-in function for FPS modificationIn OpenCV, there is a built-in function set() aimed to change the frame rate. However, when you set a lower fps, OpenCV will not add or remove frames from the video stream. Instead, it may internally drop frames as needed to achieve the desired fps. The mechanism depends on the backend and video source. 1234567bool glcvCanvas::setVideo(const std::string&amp; videoPath) { cv::VideoCapture cap(videoPath); if (!cap.isOpened()) return false; LOGI(&quot;Number of frames in the video file: %d\\tVideo FPS: %f\\n&quot;,cap.get(CAP_PROP_FRAME_COUNT), cap.get(cv::CAP_PROP_FPS)); LOGI(&quot;Video Capture Backend: %s\\n&quot;, cap.getBackendName()); //cap.set(cv::CAP_PROP_FPS, 5); Re-encode the videoIn our case, the backend for video capture is FFmpeg. Although the FFmpeg supports frame rate modification by inserting command like1ffmpeg -i &lt;input&gt; -filter:v fps=30 &lt;output&gt; it will also drop or duplicate frames as necessary. That is an undesired side effect in our case. Therefore, in order to achieve the target frame rate without dropping frames, a dynamic delay is introduced for each frame. The multi-threading section will be discussed in the next part.The LOGI() macro function is defined as the wxLogInfo() (exactly the same as wxLogVerbose()) from wxWidgets libarary. 12345678910111213141516171819202122232425262728double target_fps = cap.get(cv::CAP_PROP_FPS);double frame_time = 1000.0 / target_fps;LOGI(&quot;Number of frames: %f\\tVideo FPS: %f\\n&quot;, cap.get(cv::CAP_PROP_FRAME_COUNT), target_fps);{ std::unique_lock&lt;std::mutex&gt; medialock(mp.mediaMutex); mp.thread_running = true;}cv::Mat frame;while (!stopThread) { auto start = std::chrono::high_resolution_clock::now(); cap &gt;&gt; frame; if (frame.empty()) break; set(frame); auto end = std::chrono::high_resolution_clock::now(); auto elapsedMilliseconds = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count(); if (elapsedMilliseconds &lt; frame_time) { std::this_thread::sleep_for(std::chrono::milliseconds(static_cast&lt;long long&gt;(frame_time - elapsedMilliseconds))); }}cap.release();{ std::unique_lock&lt;std::mutex&gt; medialock(mp.mediaMutex); mp.thread_running = false;}c_v.notify_one(); Muti-thread media sources selectionIn most cases, if there’s a thread currently running which is manipulating the media, we expect it would be safely terminated before proceeding with new operations. Therefore, this section will check for a running thread, request the video to stop, wait for the thread to stop, reset the video playing flag, and unlock the mutex. Detachable or joinable:A thread can be detachable or joinable. Detachable threads are typically used when the parent thread does not need to wait for or synchronize with the detached thread’s completion. Joining a thread involves waiting for the thread to finish executing and obtaining its return value or status. This can be useful when the parent thread relies on the results of the child thread or needs to ensure proper synchronization before proceeding. In our case, we expect the previous video process to be terminated properly as we selecting a new source to display. Note that the logging information for the running thread is probably blocked on the log view, but this part of multi-thread code does it functionality properly. 1234567891011121314151617181920212223242526272829void targetCanvas::selectSource(int src){ image_source = (image_source_t)(src % TARGET_LAST); if (image_source == TARGET_FILE) { std::unique_lock&lt;std::mutex&gt; medialock(mediaMutex); if (thread_running) { stopThread = true; c_v.wait(medialock, []{return !thread_running; }); stopThread = false; } std::string fileExtension = getFileExtension(imageFile.ToStdString()); std::transform(fileExtension.begin(), fileExtension.end(), fileExtension.begin(), ::tolower); medialock.unlock(); if (fileExtension == &quot;mp4&quot; || fileExtension == &quot;avi&quot; || fileExtension == &quot;mov&quot;) { setVideo(imageFile.ToStdString()); } else { cv::Mat image = cv::imread(imageFile.ToStdString(), cv::IMREAD_ANYCOLOR); if (image.empty()) { set_text(&quot;ERROR&quot;); render_call(); } else { set(image); } } }}","link":"/2023/10/24/A-media-stream-based-on-OpenCV-and-OpenGL/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/09/11/hello-world/"}],"tags":[],"categories":[],"pages":[]}